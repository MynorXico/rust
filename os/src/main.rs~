extern crate rand;
extern crate std_semaphore;

use std::sync::mpsc::sync_channel; // multiple producer, single consumer
use std::thread;
use rand::Rng;
use std::time::Duration;
use std_semaphore::Semaphore;
use std::sync::Arc;

fn main(){
	// Canal con tamaño definido (buffer)
	let (tx, rx) = sync_channel(cap); // tx -> transmisor, rx -> receptor

	//let tx1 = mpsc::Sender::clone(&tx);
	
	// Semáforos (empty, data)
	let empty_c = Arc::new(Semaphore::new(cap_u));
	let data_c = Arc::new(Semaphore::new(0));
	// Mapeo de semáforos sobre heap
	let empty_p = empty_c.clone();
	let data_p = data_c.clone();
	
	// Propiedades del consumidor
	let max_eating_time = 3;
	
	// Propiedades del productor
	let max_baking_time = 10;
	let cap = 3;
	let cap_u = cap as isize;
	
	// Proceso de restaurantes
	println!("All you can eat ¡TACOS!");
	
	// Nuevo thread
	let handle = thread::spawn(move||{ // Asignar variable permite hacer "join"
		let mut counter = 0;	// mut permite modificar la variable (mutable)
		while true {
			let t = rand::thread_rng().gen_range(0,max_baking_time);
			//empty_p.acquire();// wait on empty
			tx.try_send("taco").unwrap();
			//data_p.release();// send signal to data
			println!("Se preparó taco #{}", counter);
			counter = counter + 1;
			thread::sleep(Duration::from_secs(t));
		}
	});
	
	let mut order = 0;
	thread::sleep(Duration::from_secs(5));

	while true {
		//data_c.acquire();// wait on data
		let received = rx.try_recv().unwrap();
		//empty_c.release();// send signal s
		println!("Se consumió {} #{}", received, order);
		let eating_time = rand::thread_rng().gen_range(1,max_eating_time);
		thread::sleep(Duration::from_secs(eating_time));
		order = order +1;
	}
	
	handle.join().unwrap();
}
	
